import{_ as a,c as l,o as i,R as e}from"./chunks/framework.5dd80646.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"性能优化/web性能优化.md"}'),o={name:"性能优化/web性能优化.md"},t=e('<blockquote><p>web 性能优化主要分为两类：加载时优化与运行时优化； 从以下几个方面考虑；减少请求次数、减少资源加载量、减少请求耗时、提高页面响应速度注重用户体验； 性能优化也有相应的代价，需要根据实际场景测试后进行权衡，避免不必要的优化。</p></blockquote><h3 id="_1-dns-服务优化" tabindex="-1">1.DNS 服务优化 <a class="header-anchor" href="#_1-dns-服务优化" aria-label="Permalink to &quot;1.DNS 服务优化&quot;">​</a></h3><ul><li>采用 DNS 加速器加速 DNS 解析；</li><li>配置 host，减少 DNS 解析；</li></ul><h3 id="_2-tcp-连接复用-keep-alive" tabindex="-1">2.TCP 连接复用 keep-alive <a class="header-anchor" href="#_2-tcp-连接复用-keep-alive" aria-label="Permalink to &quot;2.TCP 连接复用 keep-alive&quot;">​</a></h3><ul><li>HTML，css，js等文件可以通过一次 TCP 连接发起请求</li></ul><h3 id="_3-sql-优化" tabindex="-1">3.SQL 优化 <a class="header-anchor" href="#_3-sql-优化" aria-label="Permalink to &quot;3.SQL 优化&quot;">​</a></h3><ul><li>通过优化 SQL 查询数据库的时间，减少 waiting 时间</li></ul><h3 id="_4-提高服务器带宽" tabindex="-1">4.提高服务器带宽 <a class="header-anchor" href="#_4-提高服务器带宽" aria-label="Permalink to &quot;4.提高服务器带宽&quot;">​</a></h3><ul><li>升级服务器带宽提高响应速度</li></ul><h3 id="_5-gzip-压缩" tabindex="-1">5.gzip 压缩 <a class="header-anchor" href="#_5-gzip-压缩" aria-label="Permalink to &quot;5.gzip 压缩&quot;">​</a></h3><ul><li>Content-Encoding: gzip 后台开启 gzip 压缩响应资源</li><li>浏览器解压缩资源</li></ul><h3 id="_6-优化-css" tabindex="-1">6.优化 css <a class="header-anchor" href="#_6-优化-css" aria-label="Permalink to &quot;6.优化 css&quot;">​</a></h3><ul><li>去除冗余的 css 选择器和内容，减少重复渲染</li></ul><h3 id="_7-优先加载-css" tabindex="-1">7.优先加载 css <a class="header-anchor" href="#_7-优先加载-css" aria-label="Permalink to &quot;7.优先加载 css&quot;">​</a></h3><ul><li>css 先加载呈现页面内容，再加载 js 资源</li></ul><h3 id="_8-懒加载" tabindex="-1">8.懒加载 <a class="header-anchor" href="#_8-懒加载" aria-label="Permalink to &quot;8.懒加载&quot;">​</a></h3><ul><li>先加载首屏资源，提高页面响应速度</li></ul><h3 id="_9-资源预加载" tabindex="-1">9.资源预加载 <a class="header-anchor" href="#_9-资源预加载" aria-label="Permalink to &quot;9.资源预加载&quot;">​</a></h3><ul><li>一些重要的资源可以预先加载，提高用户点击时的页面响应速度，比如上一页、下一页内容</li></ul><h3 id="_10-利用-http-缓存" tabindex="-1">10.利用 HTTP 缓存 <a class="header-anchor" href="#_10-利用-http-缓存" aria-label="Permalink to &quot;10.利用 HTTP 缓存&quot;">​</a></h3><ul><li>除首页 HTML 之外资源可以利用 Cache-Control: max-age 强制缓存</li><li>利用 md5 对资源添加版本号</li><li>当资源发生更新时，版本号会变化，重新去服务器获取新资源</li></ul><h3 id="_11-多个域名分批请求" tabindex="-1">11.多个域名分批请求 <a class="header-anchor" href="#_11-多个域名分批请求" aria-label="Permalink to &quot;11.多个域名分批请求&quot;">​</a></h3><ul><li>一个域名的最大并发请求数是有限制的</li><li>将资源进行分类，不同的 CDN 域名请求不同的资源，提高并发请求数</li><li>cookie-free: css 资源，图片资源等利用 CDN 域名可以不用携带 cookie，减少上传量</li></ul><h3 id="_12-采用-http2-0" tabindex="-1">12.采用 HTTP2.0 <a class="header-anchor" href="#_12-采用-http2-0" aria-label="Permalink to &quot;12.采用 HTTP2.0&quot;">​</a></h3><ul><li>多路复用；</li><li>头部压缩；</li><li>服务端推送</li></ul><h3 id="_13-服务端渲染" tabindex="-1">13.服务端渲染 <a class="header-anchor" href="#_13-服务端渲染" aria-label="Permalink to &quot;13.服务端渲染&quot;">​</a></h3><ul><li>服务端渲染的网站则会渲染完页面再返回 HTML 文件，客户端只需解析 HTML 即可</li><li>首屏渲染速度提高，同时利于 SEO 优化</li></ul><h3 id="_14-采用-iconfont-字体图标" tabindex="-1">14.采用 iconfont 字体图标 <a class="header-anchor" href="#_14-采用-iconfont-字体图标" aria-label="Permalink to &quot;14.采用 iconfont 字体图标&quot;">​</a></h3><ul><li>字体图标生成文件小，矢量图不失真</li><li>可以和字体一样设置属性</li></ul><h3 id="_15-减少页面的重排重绘" tabindex="-1">15.减少页面的重排重绘 <a class="header-anchor" href="#_15-减少页面的重排重绘" aria-label="Permalink to &quot;15.减少页面的重排重绘&quot;">​</a></h3><ul><li>JS避免直接修改样式，通过替换 class 来修改样式</li><li>合理利用文档流特点，脱离文档流使得操作 DOM 对页面其它元素的影响降低</li><li>使用 CSS3 的 transform 触发浏览器开启 GPU 加速，如<code>transform: translateZ(0)</code></li><li>减少浮动的使用，减少渲染性能消耗</li></ul><h3 id="_16-添加-favicon-ico" tabindex="-1">16.添加 favicon.ico <a class="header-anchor" href="#_16-添加-favicon-ico" aria-label="Permalink to &quot;16.添加 favicon.ico&quot;">​</a></h3><ul><li>如果没有设置图标 ico，浏览器默认的图标会多发送一个 404 或者 500 的请求</li></ul><h3 id="_17-采用事件委托添加事件" tabindex="-1">17.采用事件委托添加事件 <a class="header-anchor" href="#_17-采用事件委托添加事件" aria-label="Permalink to &quot;17.采用事件委托添加事件&quot;">​</a></h3><ul><li>利用事件冒泡机制，通过指定一个事件来托管子元素的事件</li><li>多数鼠标事件、键盘事件都适合采用事件委托</li></ul>',35),r=[t];function h(n,s,c,u,d,_){return i(),l("div",null,r)}const f=a(o,[["render",h]]);export{q as __pageData,f as default};
